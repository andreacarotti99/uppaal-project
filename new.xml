<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/**********************************************************************************************
/******************************* GLOBAL VARIABLES *********************************************
/**********************************************************************************************/
clock general_clock;


chan enter, start, wait, leave;
urgent chan waitingToLeave, waitingToEnter;
/*
channel declared urgent to inizialize every element of the system in the same moment
*/
urgent broadcast chan initialization, updateStatus;

/*
constant parameters of the system
*/
const int R = 2;
const int RECHARGE = 5;                 //how much charge a train will gain in a station
const int CHARGE_DROP = 3;              //how much charge a train will lose while traveling
const int CHARGE_DROP_WAIT = 2;        //how much charge a train will lose while waiting to enter a station  

const int PERC_CHARGE_TRAIN_MUST_HAVE = 80;               //expressed in x/100 so in this case 80 refers to 80%
const int PERC_DIST_TRAIN_MUST_COVER = 150;  //the train need to be able to cover at least 1.5x times the distance from next station
const int TAU = 10000;
/*
first element is the distance in km from station 1 to station 2, 
second element is the distance in km from station 2 to station 3
EXPRESSED IN UNITS
*/
const int lineDistance[2] = { 23, 35 };
/*
first element is the max time needed to get from station 1 to 2
second element is the max time needed to get from station 2 to 3
EXPRESSED IN CLOCKS
*/
const int lineMaxDelay[2] = { 50, 80 };

/*
number of available trucks free in the INDEX station
*/
int stationAvailableTrucks[3] = { 0, 3, 3 };

/*
number of total trucks free in the INDEX station
*/
const int stationNumberOfTrucks[3] = { 3, 1, 2 };

/*
vector useful to know if a train is going forward or backward: 0-&gt;1-&gt;2
*/
bool trainGoingForward[3] = { true, true, true };

/*
current distance of each train to reach the next station -- Expressed in UNITS
*/
int trainDistanceToNextStation[3] = { 23, 23, 23 };

/*
current time left of each train to reach the next station -- Expressed in CLOCKs
*/
int trainTimeLeft[3] = { 50, 50, 50 };

/*
Matrix useful to know which train wants to access each station
      t0     t1        t2
s0    false  false    false
s1    false  false    false
s2    false  false    false
*/
bool trainWantsToAccess[3][3];
/*
Matrix used to know which train have gained access to each station
*/
bool trainCanAccess[3][3];

/*
Matrix used to know which train wants to leave the station
*/
bool trainWantsToLeave[3][3];

/*
Matrix used to know which train have gained the right to leave each station
*/
bool trainCanLeave[3][3];

/*
this is the max charge of train INDEX
*/
const int trainMaxCharge[3] = { 200, 200, 200 };

/*
charges of train, first element charge of Train(0), second element charge of Train(1) and third element charge of Train(2)
*/
int trainActualCharge[3] = { 200, 200, 200 };

/*
this is a sort of map: it provides information of where are currently the trains,
the train is the INDEX so if for example Train(0) is at station 0, Train(1) is at
station 1, and Train(2) is at station 2 is initialized like this:
int whereIsTrain[3] = {0, 1, 2};
*/
int trainActualStation[3]={ 0,0,0 };

/*
same as above, but maps the next station for each train
*/
int trainNextStation[3] = { 1, 1, 1 };

/*
velocity of Train(i)
EXPRESSED in UNITS/CLOCK
*/
const int trainVelocity[3] = { 10, 10, 10 };


/**********************************************************************************************
/******************************* GLOBAL FUNCTIONS *********************************************
/**********************************************************************************************/
</declaration>
	<template>
		<name>Line</name>
		<parameter>int NumberTrains, int NumberStations</parameter>
		<declaration>// Line Clocks

// Line Variables
/*
typedef struct{
    int distance[2];    //distance (in km) between each pair of consecutive stations
    int max_delay[2];    //maximum time to reach the following station: associated to each pair of consecutive stations
}line;
*/

// Line Functions 

void initialize_all() {
    int i,j;
    for(i=0; i&lt;3; i++) {
        for(j=0; j&lt;3; j++){
            trainWantsToAccess[i][j] = false;
            trainCanAccess[i][j] = false;
            trainWantsToLeave[i][j] = false;
            trainCanLeave[i][j] = false;
        }
    }

    for(i=0; i&lt;3; i++){
    
    }
}</declaration>
		<location id="id0" x="-365" y="-535">
			<name x="-390" y="-569">working</name>
		</location>
		<location id="id1" x="-570" y="-535">
			<name x="-586" y="-569">initial</name>
			<committed/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-510" y="-552">initialization!</label>
			<label kind="assignment" x="-510" y="-535">initialize_all()</label>
			<nail x="-391" y="-535"/>
		</transition>
	</template>
	<template>
		<name>Station</name>
		<parameter>int StationNumber</parameter>
		<declaration>
/*
retrieves the # of available trucks
*/
int availableTrucks(){
    return stationAvailableTrucks[StationNumber];
}






</declaration>
		<location id="id2" x="-1326" y="-926">
			<name x="-1385" y="-909">waiting_for_trains</name>
		</location>
		<location id="id3" x="-1326" y="-1121">
			<name x="-1317" y="-1155">idle</name>
		</location>
		<location id="id4" x="-952" y="-1122">
			<name x="-962" y="-1156">fully_occupied</name>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-1088" y="-952">availableTrucks()&gt;0</label>
			<label kind="synchronisation" x="-1071" y="-969">updateStatus?</label>
			<nail x="-952" y="-926"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="-1232" y="-1147">availableTrucks() == 0</label>
			<label kind="synchronisation" x="-1232" y="-1164">initialization?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="guard" x="-1232" y="-1062">availableTrucks()==0</label>
			<label kind="synchronisation" x="-1232" y="-1079">updateStatus?</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="guard" x="-1479" y="-1062">availableTrucks() &gt; 0</label>
			<label kind="synchronisation" x="-1428" y="-1079">initialization?</label>
		</transition>
	</template>
	<template>
		<name>StationManager</name>
		<declaration>/*
variables to check before letting in/out a train
*/
bool canEnter = false;
bool canLeave = false;

/*
function to check if a train can enter the current station,
if so update the matrix "trainCanAccess"
*/
void checkIfTrainCanEnterOld(){
    int i,j; //i is the station,j is the train
    int stationIndex; 
    for (i=0; i&lt;3; i++){
        for(j=0; j&lt;3; j++){
            if(trainWantsToAccess[i][j] and (not trainCanAccess[i][j])){
                stationIndex = i;
                if(stationAvailableTrucks[stationIndex] &gt; 0) {
                    trainCanAccess[i][j] = true;
                    stationAvailableTrucks[stationIndex] -= 1;
                    canEnter = true;
                }
            }                
            
        }
    }
}

/*
check if train can enter with also the check on which train has the lower charge
*/
void checkIfTrainCanEnter(){
    int i,j; //i is the station,j is the train
    int trainSavedCharge = 2000;
    int trainSavedIndex = -1;
    bool found = false;

    int stationIndex; 
    for (i=0; i&lt;3; i++){
        for(j=0; j&lt;3; j++){
            if(trainWantsToAccess[i][j] and (not trainCanAccess[i][j])){
                //check whether the train was the one with the least charge

                if (trainActualCharge[j] &lt; trainSavedCharge){
                    trainSavedIndex = j;
                    trainSavedCharge = trainActualCharge[j];
                    stationIndex = i;
                    found = true;
                } 
            }               
        }
    }
    if(stationAvailableTrucks[stationIndex] &gt; 0 &amp;&amp; found) {
        trainCanAccess[stationIndex][trainSavedIndex] = true;
        stationAvailableTrucks[stationIndex] -= 1;
        canEnter = true;
    }
}




/*
check if a train is willing to leave, so update the matrix trainCanLeave
*/
void checkIfTrainCanLeave(){
    int i,j; //i is the station,j is the train
    int stationIndex; 
    for (i=0; i&lt;3; i++){
        for(j=0; j&lt;3; j++){
            if(trainWantsToLeave[i][j] and (not trainCanLeave[i][j])){
                //no longer needed check policy here... the station manager always permits to leave because the train already made the checks
                stationIndex = i;
                trainCanLeave[i][j] = true;
                stationAvailableTrucks[stationIndex] += 1;
                canLeave = true;
            }                
        }
    }
}




</declaration>
		<location id="id5" x="-1037" y="-1377">
			<name x="-1047" y="-1411">idle</name>
		</location>
		<location id="id6" x="-1037" y="-1165">
			<name x="-1020" y="-1190">working</name>
			<urgent/>
		</location>
		<location id="id7" x="-1453" y="-1028">
			<name x="-1487" y="-1011">checkEnter</name>
			<committed/>
		</location>
		<location id="id8" x="-1453" y="-1165">
			<name x="-1504" y="-1199">letEnter</name>
			<committed/>
		</location>
		<location id="id9" x="-663" y="-1028">
			<name x="-697" y="-1011">checkLeave</name>
			<committed/>
		</location>
		<location id="id10" x="-663" y="-1165">
			<name x="-654" y="-1199">letLeave</name>
			<committed/>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id9"/>
			<target ref="id6"/>
			<label kind="guard" x="-824" y="-1105">not canLeave</label>
			<label kind="synchronisation" x="-807" y="-1122">wait!</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="guard" x="-1326" y="-1113">not canEnter</label>
			<label kind="synchronisation" x="-1300" y="-1130">wait!</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-884" y="-1207">updateStatus!</label>
			<label kind="assignment" x="-884" y="-1190">canLeave = false</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id10"/>
			<label kind="guard" x="-654" y="-1105">canLeave</label>
			<label kind="synchronisation" x="-654" y="-1122">leave!</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-1020" y="-1062">waitingToLeave?</label>
			<label kind="assignment" x="-1020" y="-1045">checkIfTrainCanLeave()</label>
			<nail x="-1037" y="-1028"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-1258" y="-1207">updateStatus!</label>
			<label kind="assignment" x="-1258" y="-1190">canEnter = false</label>
			<nail x="-1335" y="-1165"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="guard" x="-1547" y="-1113">canEnter</label>
			<label kind="synchronisation" x="-1547" y="-1130">enter!</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-1207" y="-1062">waitingToEnter?</label>
			<label kind="assignment" x="-1207" y="-1045">checkIfTrainCanEnter()</label>
			<nail x="-1037" y="-1028"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-1130" y="-1318">initialization?</label>
		</transition>
	</template>
	<template>
		<name>Train</name>
		<parameter>int TrainNumber</parameter>
		<declaration>// Train Clocks
clock enterReqClock; 
clock timeTraveling; //must be reset as soon as a train enters a station

int reAsk;

/**********************************************************************************************
/******************************** TRAIN FUNCTIONS *********************************************
/**********************************************************************************************/

/*
function to raise the battery level of a train -- policy needed
*/
void recharge(){
    if( (trainActualCharge[TrainNumber] + RECHARGE)  &lt; trainMaxCharge[TrainNumber] )
        trainActualCharge[TrainNumber] += RECHARGE;
    else
        trainActualCharge[TrainNumber] = trainMaxCharge[TrainNumber];
}
/*
function to update the charge of a train 
*/
void loose_charge(int amount){
    if( (trainActualCharge[TrainNumber] - amount) &gt;= 0 )
        trainActualCharge[TrainNumber] -= amount;
    else 
        trainActualCharge[TrainNumber] = 0;
}

/*
function to update the distance to the next station
*/
void update_distance (){
    if ( (trainDistanceToNextStation[TrainNumber] - trainVelocity[TrainNumber]) &gt; 0 )
        trainDistanceToNextStation[TrainNumber] -= trainVelocity[TrainNumber];
    else
        trainDistanceToNextStation[TrainNumber] = 0;
}

/*
function used to update the next station of each train
*/
void updateNextStation(int trainId) {
    if( trainGoingForward[trainId] ) {
        if(trainActualStation[trainId] &lt; 2 )
            trainNextStation[trainId] += 1;
        else{
            trainGoingForward[trainId] = false; //end of line reached! change direction
            trainNextStation[trainId] -= 1;
        }
    }
    else{
        if(trainActualStation[trainId] &gt; 0)
            trainNextStation[trainId] -= 1;
        else {
            trainGoingForward[trainId] = true;    //first station of line reached! change direction
            trainNextStation[trainId] += 1;
        }
    }
}

/*
update the maximum time a train can take to get to the following station
*/
void updateNextTime(int TrainNumber) {
    int index;
    if ( trainActualStation[TrainNumber] &lt; trainNextStation[TrainNumber] ) {
        index = trainActualStation[TrainNumber];
    }
    else {
        index = trainNextStation[TrainNumber];
    }
    trainTimeLeft[TrainNumber] = lineMaxDelay[index];
}

/*
update the distance to reach the following station
*/
void updateNextDistance(int TrainNumber) {
    int index;
    if ( trainActualStation[TrainNumber] &lt; trainNextStation[TrainNumber] )
        index = trainActualStation[TrainNumber];
    else 
        index = trainNextStation[TrainNumber];
    trainDistanceToNextStation[TrainNumber] = lineDistance[index];
    
}

/*
function to update the time left ti reach the next station -- policy needed
*/
void updateTimeLeft (){
    trainTimeLeft[TrainNumber] -= 1;
}

/********************************************************************/
/*********************************BEGIN POLICIES*********************/
/********************************************************************/

/*
first policy: 
 - if the train has charge &gt;= 80% of its max charge
 - if the distance it can cover is at least 1.5x of the distance to next station multiplied by the drop charge factor
*/
bool checkPolicyOne(int trainIndex){
    if ( trainActualCharge[trainIndex] &gt;= (PERC_CHARGE_TRAIN_MUST_HAVE * trainMaxCharge[trainIndex])/100  and 
         trainActualCharge[trainIndex] &gt;= (PERC_DIST_TRAIN_MUST_COVER * trainDistanceToNextStation[trainIndex] * CHARGE_DROP)/100  )
            return true;
    else
            return false;
}

/*
second policy (useless just for testing purpose):
 - if the train has enough charge to travel from station 0 to last station (considering the charge drop)
*/
bool checkPolicyTwo(int trainIndex){
    int i;
    int totalLineDistance = 0;
    for (i = 0; i &lt; 2; i++){
        totalLineDistance += lineDistance[i];
    }
    if (trainActualCharge[trainIndex] &gt;= totalLineDistance * CHARGE_DROP)
        return true;
    else
        return false;
}
/*
third policy:
 - if the station is a bottleneck, the train, provided that can reach the next station, leaves
 - otherwise it follows the first policy (if not the train would leave the station only if it is a bottleneck)
*/
bool checkPolicyThree(int trainIndex){
    int stationIndex = trainActualStation[TrainNumber];
    //if it's a bottleneck and can reach next station needs to leave ASAP
    if ( stationAvailableTrucks[stationIndex] == 0 and
         trainActualCharge[trainIndex] &gt;= trainDistanceToNextStation[trainIndex] * CHARGE_DROP)
            return true;
    else if(trainActualCharge[trainIndex] &gt;= (PERC_DIST_TRAIN_MUST_COVER * trainDistanceToNextStation[trainIndex] * CHARGE_DROP)/100 )
            return true;
    else
            return false;
}

/********************************************************************/
/*********************************END POLICIES***********************/
/********************************************************************/





/*
naive implementation of policy to let a train leave the station
*/
void updateIfTrainWantsToLeave(){
    if( (trainActualCharge[TrainNumber] &gt;= trainDistanceToNextStation[TrainNumber]* CHARGE_DROP) and                        //check the charge
        (trainTimeLeft[TrainNumber] &gt; (trainDistanceToNextStation[TrainNumber] / trainVelocity[TrainNumber])) )             //check the time left
    {
        if (checkPolicyThree(TrainNumber)){
            int stationIndex = trainActualStation[TrainNumber];
            trainWantsToLeave[stationIndex][TrainNumber] = true;
        }
    }
}
/*
function used to update all the information for the travel the train is going to run into:
- train current station
- train next station
- train next time (i.e. the max time that can take the following trip)
- train next distance (i.e. the distance to reach the next station)
The order of the updates is crucial!
*/
void updateTravelInfo() {
    int stationIndex = trainNextStation[TrainNumber];

    trainActualStation[TrainNumber] = trainNextStation[TrainNumber];
    updateNextStation(TrainNumber);
    updateNextTime(TrainNumber);
    updateNextDistance(TrainNumber);
    
    trainWantsToAccess[stationIndex][TrainNumber] = false;
    trainCanAccess[stationIndex][TrainNumber] = false;
}

/*
check if a train can proceed or must stop since 
- either it is out of power
- or the time is exceeded
*/
bool goOnCheck(){
    return ( (trainTimeLeft[TrainNumber] &gt; 0 ) and (trainActualCharge[TrainNumber] &gt; 0) );
}

/*
update matrix info if a train wants to enter a station
*/
void trainWantsToEnter(bool val){
    int stationIndex = trainNextStation[TrainNumber];
    trainWantsToAccess[stationIndex][TrainNumber] = val;
}

/*
check if a train can actually enter the next station
*/
bool trainAccessGranted(){
    int stationIndex = trainNextStation[TrainNumber];
    return trainCanAccess[stationIndex][TrainNumber];
}

/*
check if a train can actually leave the current station
*/
bool trainCanLeaveStation(){
    int stationIndex = trainActualStation[TrainNumber];
    return trainCanLeave[stationIndex][TrainNumber];
}

/*
check if a train wants to leave the current station
*/
bool trainWantsToLeaveStation(){
    int stationIndex = trainActualStation[TrainNumber];
    return trainWantsToLeave[stationIndex][TrainNumber];
}

/*
update matrix : train doesn't want to leave anymore, it left
*/
void updateTrainLeft(){
    int stationIndex = trainActualStation[TrainNumber];
    trainWantsToLeave[stationIndex][TrainNumber] = false;
    trainCanLeave[stationIndex][TrainNumber] = false;
}

/*
check if the train has no more time to reach the destination
*/
bool timeOver() {
    return trainTimeLeft[TrainNumber]==0;
}

/*
check if the train has no more time to reach the destination
*/
bool chargeOver() {
    return trainActualCharge[TrainNumber]==0;
}













</declaration>
		<location id="id11" x="-986" y="-1037">
			<name x="-1020" y="-1063">idle</name>
		</location>
		<location id="id12" x="-1215" y="-833">
			<name x="-1360" y="-825">waiting_in_a_station</name>
		</location>
		<location id="id13" x="-595" y="-833">
			<name x="-595" y="-867">traveling</name>
		</location>
		<location id="id14" x="-1700" y="-833">
			<name x="-1759" y="-867">ready_to_enter</name>
		</location>
		<location id="id15" x="-1215" y="-459">
			<name x="-1249" y="-442">out_of_power</name>
		</location>
		<location id="id16" x="-1215" y="-561">
			<name x="-1257" y="-544">out_of_time</name>
		</location>
		<location id="id17" x="-935" y="-833">
			<name x="-977" y="-816">ready_to_leave</name>
			<committed/>
		</location>
		<location id="id18" x="-1946" y="-833">
			<name x="-2133" y="-824">waiting_outside_a_station</name>
		</location>
		<init ref="id11"/>
		<transition>
			<source ref="id18"/>
			<target ref="id14"/>
			<label kind="guard" x="-1878" y="-969">goOnCheck()
and reAsk==0</label>
			<label kind="synchronisation" x="-1878" y="-986">waitingToEnter!</label>
			<label kind="assignment" x="-1878" y="-935">trainWantsToEnter(true)</label>
			<nail x="-1895" y="-918"/>
			<nail x="-1742" y="-918"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="guard" x="-1377" y="-586">timeOver()</label>
			<nail x="-1946" y="-561"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id15"/>
			<label kind="guard" x="-1377" y="-484">chargeOver()</label>
			<nail x="-1946" y="-459"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id18"/>
			<label kind="guard" x="-2210" y="-884">goOnCheck() and
not trainAccessGranted()</label>
			<label kind="assignment" x="-2210" y="-943">loose_charge(CHARGE_DROP_WAIT),
updateTimeLeft(),
reAsk -= 1</label>
			<nail x="-2218" y="-833"/>
			<nail x="-2218" y="-960"/>
			<nail x="-1946" y="-960"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id18"/>
			<label kind="guard" x="-1895" y="-756">goOnCheck() and
not trainAccessGranted()</label>
			<label kind="synchronisation" x="-1895" y="-824">wait?</label>
			<label kind="assignment" x="-1895" y="-807">loose_charge(CHARGE_DROP_WAIT),
updateTimeLeft(), reAsk = R,
trainWantsToEnter(false)</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id13"/>
			<label kind="guard" x="-799" y="-884">trainCanLeaveStation()
and goOnCheck()</label>
			<label kind="synchronisation" x="-799" y="-901">leave?</label>
			<label kind="assignment" x="-799" y="-850">updateTrainLeft()</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id17"/>
			<label kind="guard" x="-1139" y="-875">goOnCheck() and 
trainWantsToLeaveStation()</label>
			<label kind="synchronisation" x="-1139" y="-892">waitingToLeave!</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id16"/>
			<label kind="guard" x="-1453" y="-782">trainTimeLeft[TrainNumber] == 0</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id16"/>
			<label kind="guard" x="-1139" y="-587">timeOver()</label>
			<nail x="-722" y="-561"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id16"/>
			<label kind="guard" x="-1377" y="-586">timeOver()</label>
			<nail x="-1700" y="-561"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-1105" y="-1028">initialization?</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id13"/>
			<label kind="guard" x="-518" y="-791">trainDistanceToNextStation[TrainNumber] &gt; 0
and goOnCheck()</label>
			<label kind="assignment" x="-518" y="-825">loose_charge(CHARGE_DROP), 
update_distance(), updateTimeLeft()</label>
			<nail x="-527" y="-748"/>
			<nail x="-527" y="-833"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id12"/>
			<label kind="guard" x="-1445" y="-960">not trainWantsToLeaveStation()
and goOnCheck()</label>
			<label kind="assignment" x="-1445" y="-994">updateIfTrainWantsToLeave(),
updateTimeLeft(), recharge()</label>
			<nail x="-1215" y="-1011"/>
			<nail x="-1462" y="-1011"/>
			<nail x="-1462" y="-918"/>
			<nail x="-1249" y="-918"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id15"/>
			<label kind="guard" x="-1377" y="-484">chargeOver()</label>
			<nail x="-1700" y="-459"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id15"/>
			<label kind="guard" x="-1139" y="-484">chargeOver()</label>
			<nail x="-595" y="-459"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id12"/>
			<label kind="guard" x="-1598" y="-875">goOnCheck() and trainAccessGranted()</label>
			<label kind="synchronisation" x="-1598" y="-892">enter?</label>
			<label kind="assignment" x="-1598" y="-858">updateTravelInfo()</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id14"/>
			<label kind="guard" x="-1122" y="-731">trainDistanceToNextStation[TrainNumber] == 0
and goOnCheck()</label>
			<label kind="synchronisation" x="-1122" y="-748">waitingToEnter!</label>
			<label kind="assignment" x="-1122" y="-697">trainWantsToEnter(true)</label>
			<nail x="-765" y="-680"/>
			<nail x="-1513" y="-680"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
l = Line(1,1);
s0 = Station(0);
s1 = Station(1);
s2 = Station(2);
t0 = Train(0);
t1 = Train(1);
t2 = Train(2);
sm = StationManager();
// List one or more processes to be composed into a system.
system l, s0, s1, s2, t0, t1, t2&lt;sm;
    </system>
	<queries>
		<query>
			<formula>E&lt;&gt; (t0.out_of_time or t1.out_of_time or t2.out_of_time)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; (t0.out_of_power or t1.out_of_power or t2.out_of_power)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; (trainTimeLeft[0]&gt;0 &amp;&amp; trainTimeLeft[1] &gt; 0 &amp;&amp; trainTimeLeft[2] &gt; 0)</formula>
			<comment>For all the states, it never happens that the train time left reaches 0</comment>
		</query>
	</queries>
</nta>
