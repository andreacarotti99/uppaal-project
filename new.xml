<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/**********************************************************************************************
/******************************* GLOBAL VARIABLES *********************************************
/**********************************************************************************************/
clock general_clock;

chan enter, start, wait, leave, waitingToLeave, waitingToEnter;
/*
channel declared urgent to inizialize every element of the system in the same moment
*/
urgent broadcast chan initialization;

/*
first element is the distance in km from station 1 to station 2, 
second element is the distance in km from station 2 to station 3
EXPRESSED IN UNITS
*/
const int lineDistance[2] = { 23, 35 };
/*
first element is the max time needed to get from station 1 to 2
second element is the max time needed to get from station 2 to 3
EXPRESSED IN CLOCKS
*/
const int lineMaxDelay[2] = { 20, 30 };

/*
number of available trucks free in the INDEX station
*/
int stationAvailableTrucks[3] = { 0, 2, 2 };

/*
number of total trucks free in the INDEX station
*/
const int stationNumberOfTrucks[3] = { 3, 1, 2 };

/*
vector useful to know if a train is going forward or backward: 0-&gt;1-&gt;2
*/
bool trainGoingForward[3] = { true, true, true };

/*
current distance of each train to reach the next station -- Expressed in UNITS
*/
int trainDistanceToNextStation[3] = { 23, 23, 23 };

/*
current time left of each train to reach the next station -- Expressed in CLOCKs
*/
int trainTimeLeft[3] = { 20, 20, 20 };

/*
Matrix useful to know which train wants to access each station
      t0     t1        t2
s0    false  false    false
s1    false  false    false
s2    false  false    false
*/
bool trainWantsToAccess[3][3];
/*
Matrix used to know which train have gained access to each station
*/
bool trainCanAccess[3][3];

/*
Matrix used to know which train wants to leave the station
*/
bool trainWantsToLeave[3][3];

/*
Matrix used to know which train have gained the right to leave each station
*/
bool trainCanLeave[3][3];

/*
this is the max charge of train INDEX
*/
const int trainMaxCharge[3] = { 100, 100, 100 };

/*
charges of train, first element charge of Train(0), second element charge of Train(1) and third element charge of Train(2)
*/
int trainActualCharge[3] = { 50, 5, 30 };

/*
this is a sort of map: it provides information of where are currently the trains,
the train is the INDEX so if for example Train(0) is at station 0, Train(1) is at
station 1, and Train(2) is at station 2 is initialized like this:
int whereIsTrain[3] = {0, 1, 2};
*/
int trainActualStation[3]={ 0,0,0 };

/*
same as above, but maps the next station for each train
*/
int trainNextStation[3] = { 1, 1, 1 };

/*
velocity of Train(i)
EXPRESSED in UNITS/CLOCK
*/
const int trainVelocity[3] = { 10, 10, 10 };


/**********************************************************************************************
/******************************* GLOBAL FUNCTIONS *********************************************
/**********************************************************************************************/

/*
this function is to initialize everything, right now all the parameters are hard-coded 
*/
void initialize_all(){
}</declaration>
	<template>
		<name>Line</name>
		<parameter>int NumberTrains, int NumberStations</parameter>
		<declaration>// Line Clocks

// Line Variables
/*
typedef struct{
    int distance[2];    //distance (in km) between each pair of consecutive stations
    int max_delay[2];    //maximum time to reach the following station: associated to each pair of consecutive stations
}line;
*/

// Line Functions 

void initialize_all() {
    int i,j;
    for(i=0; i&lt;3; i++) {
        for(j=0; j&lt;3; j++){
            trainWantsToAccess[i][j] = false;
            trainCanAccess[i][j] = false;
            trainWantsToLeave[i][j] = false;
            trainCanLeave[i][j] = false;
        }
    }

    for(i=0; i&lt;3; i++){
    
    }
}</declaration>
		<location id="id0" x="-646" y="-518">
			<name x="-671" y="-552">working</name>
		</location>
		<location id="id1" x="-859" y="-518">
			<name x="-875" y="-552">initial</name>
			<committed/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-799" y="-535">initialization!</label>
			<label kind="assignment" x="-799" y="-518">initialize_all()</label>
			<nail x="-680" y="-518"/>
		</transition>
	</template>
	<template>
		<name>Station</name>
		<parameter>int StationNumber</parameter>
		<declaration>






</declaration>
		<location id="id2" x="-1207" y="-569">
			<name x="-1198" y="-594">waiting_for_trains</name>
		</location>
		<location id="id3" x="-1207" y="-713">
			<name x="-1198" y="-747">idle</name>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-1309" y="-671">initialization?</label>
		</transition>
	</template>
	<template>
		<name>StationManager</name>
		<declaration>
int canEnter = 0;
int canLeave = 0;

/*
function to check if a train can enter the current station,
if so update the matrix "trainCanAccess"
*/
void checkIfTrainCanEnter(){
    int i,j; //i is the station,j is the train
    int stationIndex; 
    for (i=0; i&lt;3; i++){
        for(j=0; j&lt;3; j++){
            if(trainWantsToAccess[i][j] and (not trainCanAccess[i][j])){
                stationIndex = i;
                if(stationAvailableTrucks[stationIndex] &gt; 0) {
                    trainCanAccess[i][j] = true;
                    stationAvailableTrucks[stationIndex] -= 1;
                    canEnter += 1;
                }
            }                
            
        }
    }
}


/*
check if a train is willing to leave, so update the matrix trainCanLeave
*/
void checkIfTrainCanLeave(){
    int i,j; //i is the station,j is the train
    int stationIndex; 
    for (i=0; i&lt;3; i++){
        for(j=0; j&lt;3; j++){
            if(trainWantsToLeave[i][j] and (not trainCanLeave[i][j])){
                //we could check policies here ...
                stationIndex = i;
                trainCanLeave[i][j] = true;
                stationAvailableTrucks[stationIndex] += 1;
                canLeave += 1;
            }                
            
        }
    }
}


</declaration>
		<location id="id4" x="-408" y="-382">
			<name x="-418" y="-416">idle</name>
		</location>
		<location id="id5" x="-408" y="-170">
			<name x="-433" y="-144">working</name>
			<urgent/>
		</location>
		<location id="id6" x="-680" y="-34">
			<name x="-714" y="-17">checkEnter</name>
			<committed/>
		</location>
		<location id="id7" x="-824" y="-170">
			<name x="-875" y="-204">letEnter</name>
			<committed/>
		</location>
		<location id="id8" x="-204" y="-42">
			<name x="-238" y="-25">checkLeave</name>
			<committed/>
		</location>
		<location id="id9" x="-34" y="-170">
			<name x="-25" y="-204">letLeave</name>
			<committed/>
		</location>
		<init ref="id4"/>
		<transition>
			<source ref="id9"/>
			<target ref="id5"/>
			<label kind="assignment" x="-255" y="-195">canLeave -=1</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id9"/>
			<label kind="guard" x="-102" y="-85">canLeave&gt;0</label>
			<label kind="synchronisation" x="-102" y="-102">leave!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-365" y="-76">waitingToLeave?</label>
			<label kind="assignment" x="-391" y="-59">checkIfTrainCanLeave()</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="assignment" x="-621" y="-195">canEnter -= 1</label>
			<nail x="-706" y="-170"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="-850" y="-102">canEnter&gt;0</label>
			<label kind="synchronisation" x="-816" y="-119">enter!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-603" y="-76">waitingToEnter?</label>
			<label kind="assignment" x="-621" y="-59">checkIfTrainCanEnter()</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-501" y="-323">initialization?</label>
		</transition>
	</template>
	<template>
		<name>Train</name>
		<parameter>int TrainNumber</parameter>
		<declaration>// Train Clocks
clock enterReqClock; 
clock timeTraveling; //must be reset as soon as a train enters a station

/**********************************************************************************************
/******************************** TRAIN FUNCTIONS *********************************************
/**********************************************************************************************/

/*
function to raise the battery level of a train -- policy needed
*/
void recharge(){
    if( (trainActualCharge[TrainNumber] + 1)  &lt; trainMaxCharge[TrainNumber] )
        trainActualCharge[TrainNumber] += 1;
}
/*
function to update the charge of a train -- policy needed
*/
void loose_charge(){
    if( (trainActualCharge[TrainNumber] - 1) &gt;= 0 )
        trainActualCharge[TrainNumber] -= 1;
}

/*
function to update the distance to the next station -- policy needed
*/
void update_distance (){
    if ( (trainDistanceToNextStation[TrainNumber] - trainVelocity[TrainNumber]) &gt; 0 )
        trainDistanceToNextStation[TrainNumber] -= trainVelocity[TrainNumber];
    else
        trainDistanceToNextStation[TrainNumber] = 0;
}

/*
function used to update the next station of each train
*/
void updateNextStation(int trainId) {
    if( trainGoingForward[trainId] ) {
        if(trainActualStation[trainId] &lt; 2 )
            trainNextStation[trainId] += 1;
        else{
            trainGoingForward[trainId] = false; //end of line reached! change direction
            trainNextStation[trainId] -= 1;
        }
    }
    else{
        if(trainActualStation[trainId] &gt; 0)
            trainNextStation[trainId] -= 1;
        else {
            trainGoingForward[trainId] = true;    //first station of line reached! change direction
            trainNextStation[trainId] += 1;
        }
    }
}

/*
update the maximum time a train can take to get to the following station
*/
void updateNextTime(int TrainNumber) {
    int index;
    if ( trainActualStation[TrainNumber] &lt; trainNextStation[TrainNumber] ) {
        index = trainActualStation[TrainNumber];
    }
    else {
        index = trainNextStation[TrainNumber];
    }
    trainTimeLeft[TrainNumber] = lineMaxDelay[index];
}

/*
update the distance to reach the following station
*/
void updateNextDistance(int TrainNumber) {
    int index;
    if ( trainActualStation[TrainNumber] &lt; trainNextStation[TrainNumber] )
        index = trainActualStation[TrainNumber];
    else 
        index = trainNextStation[TrainNumber];
    trainDistanceToNextStation[TrainNumber] = lineDistance[index];
    
}

/*
function to update the time left ti reach the next station -- policy needed
*/
void updateTimeLeft (){
    trainTimeLeft[TrainNumber] -= 1;
}

/*
naive implementation of policy to let a train leave the station
*/
void updateIfTrainWantsToLeave(){
    if( (trainActualCharge[TrainNumber] &gt;= trainDistanceToNextStation[TrainNumber]) and                            //check the charge
        (trainTimeLeft[TrainNumber] &gt; (trainDistanceToNextStation[TrainNumber] / trainVelocity[TrainNumber])) )    //check the time left
    {
        int stationIndex = trainActualStation[TrainNumber];
        trainWantsToLeave[stationIndex][TrainNumber] = true;
    }
}
/*
function used to update all the information for the travel the train is going to run into:
- train current station
- train next station
- train next time (i.e. the max time that can take the following trip)
- train next distance (i.e. the distance to reach the next station)
The order of the updates is crucial!
*/
void updateTravelInfo() {
    trainActualStation[TrainNumber] = trainNextStation[TrainNumber];
    updateNextStation(TrainNumber);
    updateNextTime(TrainNumber);
    updateNextDistance(TrainNumber);
}

/*
check if a train can proceed or must stop since 
- either it is out of power
- or the time is exceeded
*/
bool goOnCheck(){
    return ( (trainTimeLeft[TrainNumber] &gt; 0 ) and (trainActualCharge[TrainNumber] &gt; 0) );
}

/*
update matrix info if a train wants to enter a station
*/
void trainWantsToEnter(){
    int stationIndex = trainNextStation[TrainNumber];
    trainWantsToAccess[stationIndex][TrainNumber] = true;
}

/*
check if a train can actually enter the next station
*/
bool trainAccessGranted(){
    int stationIndex = trainNextStation[TrainNumber];
    return trainCanAccess[stationIndex][TrainNumber];
}

/*
check if a train can actually leave the current station
*/
bool trainCanLeaveStation(){
    int stationIndex = trainActualStation[TrainNumber];
    return trainCanLeave[stationIndex][TrainNumber];
}

/*
check if a train wants to leave the current station
*/
bool trainWantsToLeaveStation(){
    int stationIndex = trainActualStation[TrainNumber];
    return trainWantsToLeave[stationIndex][TrainNumber];
}

/*
update matrix : train does't want to enter anymore, since it's in
*/
void updateTrainEntered(){
    int stationIndex = trainActualStation[TrainNumber];
    trainWantsToAccess[stationIndex][TrainNumber] = false;
    trainCanAccess[stationIndex][TrainNumber] = false;
}


/*
update matrix : train doesn't want to leave anymore, it left
*/
void updateTrainLeft(){
    int stationIndex = trainActualStation[TrainNumber];
    trainWantsToLeave[stationIndex][TrainNumber] = false;
    trainCanLeave[stationIndex][TrainNumber] = false;
}
</declaration>
		<location id="id10" x="-969" y="-1062">
			<name x="-1003" y="-1088">idle</name>
		</location>
		<location id="id11" x="-1215" y="-833">
			<name x="-1360" y="-825">waiting_in_a_station</name>
		</location>
		<location id="id12" x="-595" y="-833">
			<name x="-595" y="-867">traveling</name>
		</location>
		<location id="id13" x="-1700" y="-833">
			<name x="-1887" y="-816">waiting_outside_a_station</name>
		</location>
		<location id="id14" x="-1215" y="-459">
			<name x="-1249" y="-442">out_of_power</name>
		</location>
		<location id="id15" x="-1215" y="-561">
			<name x="-1257" y="-544">out_of_time</name>
		</location>
		<location id="id16" x="-935" y="-833">
			<name x="-977" y="-816">waiting_ready</name>
			<committed/>
		</location>
		<init ref="id10"/>
		<transition>
			<source ref="id16"/>
			<target ref="id12"/>
			<label kind="guard" x="-799" y="-884">trainCanLeaveStation()
and goOnCheck()</label>
			<label kind="synchronisation" x="-799" y="-901">leave?</label>
			<label kind="assignment" x="-799" y="-850">updateTrainLeft()</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id16"/>
			<label kind="guard" x="-1139" y="-875">goOnCheck() and 
trainWantsToLeaveStation()</label>
			<label kind="synchronisation" x="-1139" y="-892">waitingToLeave!</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id15"/>
			<label kind="guard" x="-1453" y="-782">trainTimeLeft[TrainNumber] == 0</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id15"/>
			<label kind="guard" x="-1139" y="-587">trainTimeLeft[TrainNumber]==0</label>
			<nail x="-722" y="-561"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id15"/>
			<label kind="guard" x="-1479" y="-587">trainTimeLeft[TrainNumber]==0</label>
			<nail x="-1547" y="-561"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1105" y="-1045">initialization?</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id13"/>
			<label kind="guard" x="-1955" y="-867">goOnCheck() and 
not trainAccessGranted()</label>
			<label kind="assignment" x="-1955" y="-901">loose_charge(),
updateTimeLeft()</label>
			<nail x="-1963" y="-833"/>
			<nail x="-1963" y="-918"/>
			<nail x="-1700" y="-918"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id12"/>
			<label kind="guard" x="-518" y="-791">trainDistanceToNextStation[TrainNumber] &gt; 0
and goOnCheck()</label>
			<label kind="assignment" x="-518" y="-825">loose_charge(), update_distance(),
updateTimeLeft()</label>
			<nail x="-527" y="-748"/>
			<nail x="-527" y="-833"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id11"/>
			<label kind="guard" x="-1615" y="-977">not trainWantsToLeaveStation() and goOnCheck()</label>
			<label kind="assignment" x="-1640" y="-994">recharge(), updateIfTrainWantsToLeave(), updateTimeLeft()</label>
			<nail x="-1215" y="-1019"/>
			<nail x="-1649" y="-1020"/>
			<nail x="-1649" y="-935"/>
			<nail x="-1232" y="-935"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id14"/>
			<label kind="guard" x="-1615" y="-485">trainActualCharge[TrainNumber]==0</label>
			<nail x="-1700" y="-459"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id14"/>
			<label kind="guard" x="-1028" y="-485">trainActualCharge[TrainNumber]==0</label>
			<nail x="-595" y="-459"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id11"/>
			<label kind="guard" x="-1598" y="-875">goOnCheck() and trainAccessGranted()</label>
			<label kind="synchronisation" x="-1598" y="-892">enter?</label>
			<label kind="assignment" x="-1598" y="-858">updateTrainEntered(), updateTravelInfo()</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id13"/>
			<label kind="guard" x="-1122" y="-731">trainDistanceToNextStation[TrainNumber] == 0
and goOnCheck()</label>
			<label kind="synchronisation" x="-1122" y="-748">waitingToEnter!</label>
			<label kind="assignment" x="-1122" y="-697">trainWantsToEnter()</label>
			<nail x="-765" y="-680"/>
			<nail x="-1513" y="-680"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
l = Line(1,1);
s0 = Station(0);
s1 = Station(1);
s2 = Station(2);
t0 = Train(0);
t1 = Train(1);
t2 = Train(2);
sm = StationManager();
// List one or more processes to be composed into a system.
system l, s0, s1, s2, t0, t1, t2, sm;
    </system>
	<queries>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
	</queries>
</nta>
